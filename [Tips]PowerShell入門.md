## 目次
 1. PowerShellの基本
 2. PowerShellの文字コードについて解説！文字化けで困らないための対処法

---  
## 1. PowerShellの基本
[PowerShellの基本（前編）](https://www.atmarkit.co.jp/ait/articles/0708/30/news137_3.html)
[PowerShellの基本（後編）](https://www.atmarkit.co.jp/ait/articles/0709/20/news125.html)

### ■命名ルールは「動詞-名詞」

| 動詞       |    概要     |
|:-----------|:-----------|
Add           |追加する
Clear         |すべて削除する
ConvertXxxxx  |変換する
Export        |エクスポートする
Copy          |複製する
Format        |整形する
Get           |取得する
Import        |インポートする
Move          |移動する
New           |新規に作成する
Remove        |削除する
Set           |設定する
Start         |開始する
Stop          |停止する
Write         |書き込み／表示する

|名詞            |   概要      |
|:---------------|:-----------|
Alias             |エイリアス
Content           |文字列
History	          |コマンド履歴
Item（ChildItem)  | 項目（フォルダ／ファイル、レジストリ項目など）
Location          |作業場所（カレントフォルダなど）
Object            |オブジェクト
Path	           |パス
Process       	|プロセス
Service	        |サービス

### ■Where-Objectコマンドレット
Where-Objectコマンドレットにおいて、条件式はスクリプト・ブロック（{ ～ }で囲まれた部分）に記述することができる。
変数「$_」はPowerShell上で利用可能な特殊変数の1つで、パイプ経由で渡されたオブジェクトを表す。
また、「-ge」は比較演算子の1つで、「以上」を表すものだ（それ以外の比較演算子は次の表を参照）。

|演算子|概要|例（条件式の部分のみ）  
|:----|:----|:----
-eq |等しい（=）	|$_.Name -eq "wga.log"
-ne	|等しくない（≠）	|$_.Name -ne "wga.log"
-gt	|より大きい（＞）	|$_.Length -gt 1MB
-ge	|以上（≧）	|$_.Length -ge 1MB
-lt	|未満（＜）	|$_.Length -lt 1MB
-le	|以下（≦）	|$_.Length -le 1MB
-like	|あいまい検索（ワイルドカード）	|$_.Name -like "*.log"
-match	|正規表現検索	|$_.Name -match "[a-z]{1,}\.log"

PowerShellの比較演算子  
ただし、文字列比較で大文字／小文字を区別する場合には「c」、しない場合には「i」を演算子の先頭に付ける。例えば「-ieq」などとする。

`PS > Get-ChildItem | Where-Object {$_.Length -ge 1MB}`


### ■ForEach-Objectコマンド
　 ForEach-Objectコマンドレットは、パイプ経由で渡された入力オブジェクトを順番に出力する。

`PS > Get-ChildItem |
>> Where-Object {$_.LastWriteTime -lt (Get-Date).AddMonths(-6)} |
>> ForEach-Object {$_.Delete()}`

### ■Format-Listコマンドレット
Format-Listコマンドレットは、パイプ経由で渡されたオブジェクトの内容をリスト形式で出力する。
コマンドレットは、デフォルトで、その処理結果をテーブル形式で出力するが、
表示すべきプロパティの数が多い場合には、テーブル形式では一部の情報が省略されてしまうなど、十分な情報が得られない。
そのような場合には、Format-Listコマンドレットでリスト形式に整形すれば、必要な情報を見やすい形式で出力できる。

`PS > Get-ChildItem | Format-List *`

### スクリプト・ファイルの実行方法
PowerShellでは「.ps1」ファイルのダブルクリックではスクリプトを起動することができないので、PowerShell上から明示的に呼び出す必要がある。

### 実行に関する注意1―PowerShellはカレント・フォルダを検索しない
PowerShellではスクリプト・ファイルを実行する場合に必ず絶対パスか相対パス形式でファイルを指定しなければならない。
ダメな例
`PS > ./Begin.ps1`
正しい例
`PS > ./Begin.ps1`
`PS > C:\Windows\Temp\Begin.ps1`
（拡張子「.ps1」は省略しても構わない）

### 実行に関する注意2―スクリプト実行ポリシーを設定すること
PowerShellではセキュリティ上の理由から、デフォルトでスクリプトの実行が無効に設定されている。
そのため、スクリプト・ファイルを実行するためには、あらかじめPowerShellのスクリプト実行ポリシーを変更しておく必要がある。
実行ポリシーを変更するにはSet-ExecutionPolicyコマンドレットを利用する。
`PS > Set-ExecutionPolicy RemoteSigned`

|実行ポリシー	|概要
|:---------|:-----------|
Restricted	|すべてのスクリプトを実行不可
AllSigned	|すべてのスクリプトに証明書を要求
RemoteSigned	|★推奨。インターネット経由でダウンロードしたスクリプトのみ証明書を要求
Unrestricted	|すべてのスクリプト実行を許可（ただしインターネット経由でダウンロードしたコードは実行確認のみあり）

### 変数の命名規則
　さてその変数を利用するに当たって、まず理解しておく必要があるのが変数の命名規則だ。前編でも簡単に触れたように、PowerShellでは変数名を以下の規則に従って命名する必要がある。

先頭文字は「$」で始まること
2文字目以降は任意の英数字、またはアンダースコア（_）であること
　厳密には${～}のように、中カッコで変数名を囲めば任意の文字を利用できる。

### 変数のデータ型
　PowerShellは、（やはり多くのスクリプティング言語と同様）データ型を区別しない言語である。
ただし厳密にはデータ型を持たないわけではなく、与えられた実データに応じてPowerShellが自動的に適切なデータ型を与えてくれる。

そこでPowerShellでは明示的に変数の型を宣言する方法も提供している。
具体的には、以下のリストのように変数名の先頭に角カッコで囲んだデータ型を明示する（*）
`PS > [System.Int32] $x = 10`
* これはPowerShellにおけるキャスト構文である。
例えば、「$x = [System.Int32] 1.3」のようにすることで、右辺の値（1.3）をInt32型にキャストすることもできる。


型名のエイリアス

|エイリアス| .NET Frameworkの型名
|:---------|:-----------|
byte	|System.Byte
int	|System.Int32
long	|System.Int64
single、float	|System.Single
double	|System.Double
decimal	|System.Decimal
char	|System.Char
bool	|System.Boolean
string	|System.String
array	|System.Array
xml	|System.Xml.XmlDocument
type	|System.Type

### 文字列の自動展開
　変数に格納できる重要なデータ型の1つとして「文字列」がある。
PowerShellでは、この文字列を表すために、細かく分けると4種類の文字列リテラルを提供している。

* シングルクォートで囲まれた文字列
* ダブルクォートで囲まれた文字列
* シングルクォートで囲まれたヒア・ドキュメント
* ダブルクォートで囲まれたヒア・ドキュメント

　ヒア・ドキュメントについては後述するとして、まず押さえておいていただきたいのは、
文字列はシングルクォート／ダブルクォートのいずれかで囲む必要があるということ、
そして、このいずれで囲むかによってPowerShellの挙動が異なるということだ。
具体的には次の例を見てほしい。

`PS > $name="山田"
PS > Write-Output "私の名前は $name です。"
私の名前は 山田 です。
PS > Write-Output '私の名前は $name です。'
私の名前は $name です。`

　このように、文字列に含まれる「$name」がシングルクォートで囲まれた場合にはそのまま出力されるのに対して、
ダブルクォートで囲まれた場合には評価された結果（ここでは「山田」）として表示される。
このように、PowerShellではダブルクォートで囲まれた文字列では「変数展開」が行われるというわけだ。

ちなみにPowerShellでは、改行文字やタブ文字のような特殊文字をエスケープ・シーケンスを利用して表現できる（以下はエスケープ・シーケンスの例だ）。

エスケープ・シーケンス	概要  
`(バッククォート)+b バックスペース`  
`(バッククォート)+n	改行`  
`(バッククォート)+r	キャリッジ・リターン`  
`(バッククォート)+t	タブ`  

### ヒア・ドキュメント（here document）
ヒア・ドキュメントとは、（通常は複数行にまたがる）大量のテキストをスクリプト・インラインで記述するための仕組みだ。  
ヒア・ドキュメントは「@"＜改行＞～＜改行＞"@」（または「@'＜改行＞～＜改行＞'@」）の形式で記述できる。  

`PS > $body=@"`  
`>> こんにちは、WINGSの山田です。`  
`>> PowerShellの世界をご一緒に楽しみましょう。`  
`>> "@`
`PS > Write-Output $body`  
`>>   ……ここで［Enter］キーのみを入力して終了する`  
`こんにちは、WINGSの山田です。`  
`PowerShellの世界をご一緒に楽しみましょう。`  

複数行に及ぶ長いテキストを表す場合には（クォートの有無にかかわらず）ヒア・ドキュメントを利用することをお勧めしたい。


### 配列と連想配列
　文字列と並び、スクリプトを記述するうえで重要なデータ型が「配列」と「連想配列（ハッシュテーブル）」である。

まずはさっそく、それぞれ配列と連想配列を宣言する具体的なコードを見てみることにしよう。

`PS > $x = 1,2,3`  
`PS > Write-Output $x[0]`  
`1  ……0番目の要素を出力`  
`PS > $z = @{FirstName="Yoshihiro"; LastName="Yamada"; Birth="Shizuoka"}`  
`PS > Write-Output $z["FirstName"]`  
`Yoshihiro  ……FirstName要素を出力`
`PS > Write-Output $z.FirstName`  
`Yoshihiro  ……FirstName要素を出力`  

　配列／連想配列を生成する一般的な構文は、以下のとおりだ。

`要素, 要素, 要素, ...　……配列`  
`@{キー名=値; キー名=値; ...}　……連想配列`  

　ただし配列はカンマ演算子（,）で生成するほか、以下のように記述することもできる。

`@(要素, 要素, 要素, ...)`  

　空の配列を明示的に宣言するには、単に「()」とするのではなく、「@()」のように記述する（空の連想配列を生成する場合は「@{}」）。

　宣言された配列／連想配列にアクセスするには、

`$変数名[インデックス番号]`  
`$変数名["キー名"]`  

のように角カッコ表記でインデックス番号やキー名を指定すればよい。ただし連想配列についてはドット演算子を利用して、

`$変数名.キー名`  

の形式で取得することも可能である（プロパティ表記）。キー名が静的に決まる場合には角カッコ表記／プロパティ表記いずれを利用しても構わないが、キー名を変数として渡したいなど動的に変更する必要がある場合には、角カッコ表記を使用する必要がある。

### 単純分岐と多岐分岐
　まずは、条件分岐構文である。条件を満たした場合にのみ何らかの処理を行いたい、
あるいは、A、Bいずれかの処理を選択的に行いたいというケースで使用するのが、
if ～ elseif ～ else命令の役割だ。

　例えば以下は、変数$xが1であるかどうかを判定し、
判定結果によって異なるメッセージを表示するごく単純なスクリプトである。

`$x = 1`  
`if($x -eq 1){`  
`  Write-Output '変数$xは1です。'`  
`}else{`  
`  Write-Output '変数$xは1ではありません。'`   
`}`  

　このコードを実行すると、確かに「変数$xは1です。」というメッセージが表示されることが確認できる。
このように、if命令では与えられた条件式（ここでは「$x -eq 1」*）を判定し、
真の場合にはif直後のブロックを、偽の場合にはelseブロックを、それぞれ実行する。
ちなみに、ブロック内の命令が1文しかない場合にも、
PowerShellではスクリプト・ブロックを表す中カッコ（{ ～ }）を省略することはできない。


またif命令では、elseifブロックを使って多岐分岐を記述できる。

`$x = 100`   
`if($x -ge 80){`   
`  Write-Output '変数$xは80以上です。'`   
`}elseif($x -ge 40){`   
`  Write-Output '変数$xは40以上80未満です。'`   
`}else{`   
`  Write-Output '変数$xは40未満です。'`   
`}`   

　ここでは変数$xの値が、80以上、40以上80未満、40未満いずれであるかによって、処理を分岐している。
elseifブロックは必要に応じて複数個記述することもできる。
注意していただきたいのは、if ～ elseif ～ else命令では複数の条件に合致した場合にも、
「最初に合致したブロックのみが実行される」という点である。
ここでは、変数$xが100であるので、最初の条件式「$x -ge 80」と、
次の条件式「$x -ge 40」のいずれにも合致するが、
実際に実行されるのは最初に合致したifブロックだけである。

このように、if命令を利用すればちょっとした多岐分岐までを記述することができるが、
等価比較による多岐分岐ならば、switch ～ case命令を利用した方がシンプルに記述できる。
例えば以下にswitch命令を利用したコードを挙げておく。

`$x = 1`  
`switch($x){`  
`  1 {Write-Output '変数$xは1です。'}`  
`  2 {Write-Output '変数$xは2です。'}`  
`  3 {Write-Output '変数$xは3です。'}`  
`  default {Write-Output '変数$xは1、2、3ではありません。'}`  
`}`  

　このコードを実行すると、確かに「変数$xは1です。」というメッセージが表示されることが確認できる。
このように、switch命令では先頭で与えられた式（ここでは「$x」）と、それぞれの照合パターン（ここでは1、2、3）とを比較し、合致したブロックを実行する。
ただしここで注意していただきたいのは、（if命令と異なり）switch命令では複数のブロックに合致する場合に、「条件に合致したすべてのブロック」が実行されるという点である。
次の例は、複数のブロックがマッチするように先ほどのコードを書き換えたものである。

`$x = 1`  
`switch($x){`  
`  1 {Write-Output '変数$xは1です。'}`  
`  1 {Write-Output '変数$xは1です。（2）'}`  
`  3 {Write-Output '変数$xは3です。'}`  
`  default {Write-Output '変数$xは1、2、3ではありません。'}`  
`}`  

　この例では確かに、

`変数$xは1です。`  
`変数$xは1です。（2）`  

のような結果が返されることが確認できる。
もしもif命令同様、最初に合致したブロックのみを実行したければ、ブロックの末尾にbreak命令を記述すればよい。

`$x = 1`  
`switch($x){`  
`  1 {`  
`      Write-Output '変数$xは1です。'`  
`      break`  
`    }`  
`  1 {`  
`      Write-Output '変数$xは1です。（2）'`  
`      break`  
`    }`  
`  3 {`  
`      Write-Output '変数$xは3です。'`  
`      break`  
`    }`  
`  default {Write-Output '変数$xは1、2、3ではありません。'}`  
`}`  

　break命令により、各ブロックの末尾で制御がswitchブロック全体から脱出することになる。
複数のブロックがマッチしては困る場合、それぞれの分岐ブロックの末尾にはbreak命令を記述しておこう。
すると意図しないブロックが実行されることを防ぐことができる。


### ループ構文（1） ――for命令とforeach命令――
　for命令は、指定されたカウンタ変数によってループを制御する、最も基本的なループ構文である。
for命令を利用した具体的なコード例を次に挙げる。

`$ary=@(100,120,300)`  
`for($i=0; $i -lt 3; $i++){`  
`  $sum += $ary[$i];`  
`}`  
`Write-Output $sum`  
配列内の数値をすべて合計するためのコード（for命令を利用した場合）


　このコードを実行すると、配列内に含まれる数値（100、120、300）の合計である520が得られる。
for命令ではループの回数を、

`for(初期化式; 終了条件; 増分式)`  

の形式で指定する。

「初期化式」はループの始まりで評価される式で、
ここではカウンタ変数（ループの回数を管理するための変数）である$iを0で初期化している。
「増分式」はループの1回ごとに実行される式を、
「終了条件」はループを継続するための条件式をそれぞれ表す。
つまりこのコードでは、カウンタ変数$iを、
ループを1回実行するごとに1ずつインクリメント（増加）していき、
これを$iが3（配列サイズ）未満である間だけ繰り返すことになる。

　結果、スクリプト・ブロック（{～}）の中で定義された命令が、
$iが0～2で変化する間だけ繰り返され、$ary[0]～[2]の内容が順番に変数$sumに加算される。

　もっとも、このように配列やコレクションの内容を順番に処理するようなケースでは、
foreach命令を利用した方がより直感的にコードを記述できる。
下は先ほどのコードをforeach命令で書き換えたものだ。

`$ary=@(100,120,300)`  
`foreach($dat in $ary){`  
`  $sum += $dat;`  
`}`  
`Write-Output $sum`  
配列内の数値をすべて合計するためのコード（foreach命令を利用した場合）


　foreach命令では、

`foreach(一時変数 in 配列、コレクション){`  

のように指定することで、配列から順に要素を取り出し、
読み出す要素がなくなるまでループを繰り返す。
取り出された要素は一時変数に格納され、スクリプト・ブロック内で参照できる。

　このように、foreach命令はごく直感的に利用できる制御構文の1つであるが、
ここで1つ疑問に思われる方もいるかもしれない。
というのも、PowerShellにはコマンドレットとしてよく似た機能を持つForEach-Objectが提供されている。
これを利用すれば、foreach命令と同様の処理を行うことが可能である。
例えば先ほどの例はForEach-Objectを利用して、次のように書き換えることができる。

`@(100,120,300) | ForEach-Object {$sum += $_}`  
`Write-Output $sum`  

　多くの場合、この2つはプログラマの好みによって使い分けて構わないが、
内部的な挙動としては微妙な違いもあるので要注意だ。
というのも、foreach命令が入力元となる要素（オブジェクト）をすべて取得してからループ処理を行うのに対して、ForEach-Objectコマンドレットはオブジェクトを1つずつ読み込みながら処理する。
このため、前者の方が処理に際してより多くのメモリを必要とすることになる。
一方、一括してオブジェクトを取得するため、処理の内容によっては前者の方が高速に動作する可能性がある。
要は、消費リソースとパフォーマンスとをてんびんにかけて、両者を使い分ける必要があるということだ。


### ループ構文（2） ――while／do ～ while命令――
　while／do ～ while命令は、いずれも与えられた条件式が真と評価される間だけループを繰り返す。
例えば、先ほどfor／foreach命令で示したコードをwhile／do ～ while命令で記述すると、それぞれ次のようになる。

`※while命令を利用した例`  
`$i=0;`  
`$sum=0;`  
`$ary=@(100,120,300)`  
`while($i -lt 3){　　……変数$iが3未満の場合の間、ループを継続`  
`  $sum += $ary[$i];`  
`  $i++;`  
`}`  
`Write-Output $sum`  


`※do ～ while命令を利用した例`  
`$i=0;`  
`$sum=0;`  
`$ary=@(100,120,300)`  
`do{`  
`  $sum += $ary[$i];`  
`  $i++;`  
`}while($i -lt 3)　　……変数$iが3未満の場合の間、ループを継続`  
`Write-Output $sum`  

while／do ～ while命令を利用した例


　コードを実行すると、どちらも配列要素の合計値である520が得られる。
条件式の記述がスクリプト・ブロックの前方／後方いずれにあるかという点を除いては非常によく似た両者であるが、1点だけ大きく異なる点があるので、要注意だ。

　というのも、while命令は条件式をブロックの前方で判定（前置判断）するのに対して、do ～ while命令は条件式をブロックの後方で判定（後置判断）するのである。
つまり、do ～ while命令では条件の真偽にかかわらず、「最低1回は必ず」ループが実行されるということである。
一方、while命令ではループの開始時点で条件式が偽と評価される場合にはループは「1度も実行されない」。

### 関数の基本
　まずは、ごく基本的な関数の例として、
与えられた引数$width（底辺）、$height（高さ）に従って三角形の面積を求めるTriangle関数を定義し、これを利用するコードを見てみることにしよう（注：面積＝底辺×高さ÷2）。
以下が、そのコードだ。

`function Triangle([double] $width=1, [double] $height=1) {`  
`  return $width * $height / 2`  
`}`  

`Triangle 2 6　　# 結果は 6 と表示される　……（1）`  

与えられた引数$width／$heightに基づいて三角形の面積を求めるTriangle関数（Triangle.ps1）


　関数の構文規則については、すでになにかしらの言語を学んだことがある方ならば容易に理解できるだろうが、一応、以下にまとめておく。

`function 関数名 [(引数[=デフォルト値],...)] {`  
`  関数の本体`  
`  [return 戻り値]`  
`}`  

　引数が存在しない（あるいは引数名を明示的に宣言しない）場合には、
関数名の後ろのカッコは省略できる。
また、ここでは仮引数に対して明示的にデータ型を指定しているが、前述したように、PowerShellはデータ型の宣言を強制しない言語である。
従って、データ型の検査が不要である場合には、単に

`function Triangle($width=1, $height=1) {`  

としても構わない。

　宣言した関数を呼び出しているのは、リスト内の（1）の部分である。
ほかのプログラミング言語に慣れている方ならば、思わず

`Triangle(2,6)`  

のように書きたくなるかもしれないが、これはできないので注意が必要である。
というのも前述したように、PowerShellではカンマ演算子によって配列を表すことができる。
つまり上のような記述では、「2、6を要素に持つ配列型の引数を与える」という意味になってしまう（もしもそういう意味で記述しているならば、これは構文的に誤りではないが）。

引数は、

`関数名 引数1 引数2 ～`  

のように、空白区切りで記述しなければならないことを覚えておこう。


　またPowerShellでは、以下のように引数を明示的に指定した呼び出しも可能である。

`Triangle -width 2 -height 6`  

　この形式では、引数の指定に順番は関係ないので、

`Triangle -height 6 -width 2`  

のように記述しても構わないし、

`Triangle -height 6 -width 2 -nothing 0`  

のように、合致する仮引数が関数側に存在しない引数を指定することもできる（その場合には無視される）。
しかし、同じ引数名を複数回指定した場合にはエラーとなる。

`function Triangle([double] $width=1, [double] $height=1) {`  
`  return $width * $height / 2`  
`}`  

`Triangle -width 2 -width 6`  


### 名前付き引数と名前なし引数

　さて、先ほどは関数側で明示的に仮引数名を宣言する例について見てみた（これを「名前付き引数」と呼ぶ）。
しかしPowerShellでは、仮引数を明示的に宣言しない、「名前なし引数」を利用することも可能だ。
例えば、先ほどのTriangle関数を名前なし引数を使って定義すると、以下のように記述できる。

`function Triangle {`  
`  return $Args[0] * $Args[1] / 2`  
`}`  

先ほどのTriangle関数を名前なし引数を使って書き直した例


　このように、名前なし引数を利用した場合には、引数は自動変数$Argsを介して取得することができる。
自動変数とは、PowerShellによって自動的に値が設定されている変数のことで、
あらかじめ用途が予約されていることから「予約変数」とも呼ぶ。
例えば前回紹介した「$_」（パイプライン経由で渡されたオブジェクト）も自動変数の一種である。

　関数に渡された名前なし引数は自動変数$Args（配列）に登録されるので、
あとは「$Args[0]」のように指定することで、与えられた引数値にアクセスすることができる。
なおJavaScriptなどの言語に慣れている方は、
自動変数$Argsには関数に渡されたすべての引数値（名前付き引数／名前なし引数の双方）が含まれるように思われるかもしれないが、
PowerShellではあくまで名前なし引数だけしか含まれない。
細かい点ではあるが、意外と間違えやすいポイントなので注意してほしい。


### 変数のスコープ
　関数が登場すると、いよいよ意識しなければならなくなるのが変数のスコープだ。
スコープとは、プログラム中での変数の有効範囲のことである。
まずすべてのスコープから参照できる「グローバル・スコープ」と、関数内部でのみ有効な「ローカル・スコープ」については、読者諸兄もよくご存じであろう。
しかしPowerShellでスクリプトを記述する場合、もう1つ、「スクリプト・スコープ」の存在を意識しておく必要がある。

PowerShellでは、変数や関数は現在のスコープで作成されるのがデフォルトの挙動であるが、
もしもスクリプト・ファイル内で宣言された関数をスクリプト外から参照したければ、
Triangle関数の定義を以下のように修正すればよい。

`function global:Triangle([double] $width=1, [double] $height=1) {`  
`  return $width * $height / 2`  
`}`    

所属スコープを明示的に宣言したTriangle関数（Triangle.ps1）

　「global:」はスコープ修飾子と呼ばれるもので、
関数や変数のスコープを強制的に変更するための役割を持つ。
これにより、本来スクリプト・スコープに属するはずのTriangle関数を、
強制的にグローバル・スコープに登録している。

このスコープ修飾子は、変数に対しても
「$global:x」（グローバル変数）、
「$script:x」（スクリプト変数）、
「$local:x」（ローカル変数）のように指定することができる

## 2. PowerShellの文字コードについて解説！文字化けで困らないための対処法
[PowerShellの文字コードについて解説！文字化けで困らないための対処法](https://www.fenet.jp/infla/column/technology/powershellの文字コードについて解説！文字化けで困らな/)
